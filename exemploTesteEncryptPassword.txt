import { encryptPassword } from "../encryptPassword";
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcrypt';

// Mock do bcrypt
jest.mock('bcrypt');

describe('encryptPassword', () => {
    const mockRequest = {} as Request;
    const mockResponse = {} as Response;
    const mockNext = jest.fn() as NextFunction;

    beforeEach(() => {
        jest.clearAllMocks(); // Limpa os mocks antes de cada teste
    });

    it('deve criptografar a senha corretamente e chamar o próximo middleware', async () => {
        // Configuração do mock do bcrypt.hash
        (bcrypt.hash as jest.Mock).mockResolvedValue('hashedpassword');

        // Simula uma requisição com uma senha no corpo
        mockRequest.body = { password: 'password123' };

        // Chama a função do middleware
        await encryptPassword(mockRequest, mockResponse, mockNext);

        // Verifica se a senha no corpo da requisição foi substituída pela senha criptografada
        expect(mockRequest.body.password).toBe('hashedpassword');

        // Verifica se a função next foi chamada
        expect(mockNext).toHaveBeenCalled();
    });

    it('deve lidar com erro ao criptografar a senha', async () => {
        // Configuração do mock do bcrypt.hash para simular um erro
        (bcrypt.hash as jest.Mock).mockRejectedValue('Erro ao criptografar a senha');

        // Simula uma requisição com uma senha no corpo
        mockRequest.body = { password: 'password123' };

        // Chama a função do middleware
        await encryptPassword(mockRequest, mockResponse, mockNext);

        // Verifica se a resposta de erro foi enviada
        expect(mockResponse.status).toHaveBeenCalledWith(400);
        expect(mockResponse.send).toHaveBeenCalledWith('Erro ao criptografar a senha');

        // Verifica se a função next não foi chamada
        expect(mockNext).not.toHaveBeenCalled();
    });
});
